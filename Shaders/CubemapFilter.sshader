
#include "MonteCarlo.hlsl"

cbuffer Global : register(b0)
{
    float2 SvPositionToUVScale;
    int CubeFace;
    int MipIndex;
    int NumMips;
}

struct VSInput
{
    [[vk::location(0)]] float2 Position : POSITION;
    [[vk::location(1)]] float2 UV : TEXCOORD0;
};

float3 GetCubemapVector(float2 ScaledUVs, int InCubeFace)
{
	float3 CubeCoordinates;

	//@todo - this could be a 3x3 matrix multiply
	if (InCubeFace == 0)
	{
		CubeCoordinates = float3(1, -ScaledUVs.y, -ScaledUVs.x);
	}
	else if (InCubeFace == 1)
	{
		CubeCoordinates = float3(-1, -ScaledUVs.y, ScaledUVs.x);
	}
	else if (InCubeFace == 2)
	{
		CubeCoordinates = float3(ScaledUVs.x, 1, ScaledUVs.y);
	}
	else if (InCubeFace == 3)
	{
		CubeCoordinates = float3(ScaledUVs.x, -1, -ScaledUVs.y);
	}
	else if (InCubeFace == 4)
	{
		CubeCoordinates = float3(ScaledUVs.x, -ScaledUVs.y, 1);
	}
	else
	{
		CubeCoordinates = float3(-ScaledUVs.x, -ScaledUVs.y, -1);
	}

	return CubeCoordinates;
}


float4 VertexMain(VSInput input)
{
    return float4(input.Position , 0.0f,1.0f);
}

TextureCube CubemapTexture;
SamplerState CubeSampler ;

float4 FragmentMain(float4 SvPosition : SV_POSITION) :  SV_TARGET
{

    float2 UV = SvPosition.xy ;
    float2 ScaledUVs = UV * 2 - 1;
    float3 CubeCoordinates = GetCubemapVector(ScaledUVs,CubeFace);
    float4 OutColor = CubemapTexture.SampleLevel(CubeSampler,CubeCoordinates,0);

    return OutColor;
}
