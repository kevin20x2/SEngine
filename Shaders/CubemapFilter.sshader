
#include "MonteCarlo.hlsl"

cbuffer Global : register(b0)
{
    float2 SvPositionToUVScale;
    int CubeFace;
    int MipIndex;
    int NumMips;
}

struct VSInput
{
    [[vk::location(0)]] float3 Position : POSITION;
    [[vk::location(1)]] float2 UV : TEXCOORD0;
};

float3 GetCubemapVector(float2 ScaledUVs, int InCubeFace)
{
	float3 CubeCoordinates;

	//@todo - this could be a 3x3 matrix multiply
	if (InCubeFace == 0)
	{
		CubeCoordinates = float3(1, -ScaledUVs.y, -ScaledUVs.x);
	}
	else if (InCubeFace == 1)
	{
		CubeCoordinates = float3(-1, -ScaledUVs.y, ScaledUVs.x);
	}
	else if (InCubeFace == 2)
	{
		CubeCoordinates = float3(ScaledUVs.x, 1, ScaledUVs.y);
	}
	else if (InCubeFace == 3)
	{
		CubeCoordinates = float3(ScaledUVs.x, -1, -ScaledUVs.y);
	}
	else if (InCubeFace == 4)
	{
		CubeCoordinates = float3(ScaledUVs.x, -ScaledUVs.y, 1);
	}
	else
	{
		CubeCoordinates = float3(-ScaledUVs.x, -ScaledUVs.y, -1);
	}

	return CubeCoordinates;
}


float4 VertexMain(VSInput input) : SV_POSITION
{
    return float4(input.Position ,1.0f);
}

float D_GGX(float a2 , float NoH)
{
    float d = ( NoH * a2 - NoH) * NoH + 1;
    return a2 / (PI *d *d );
}

TextureCube CubemapTexture : register(t1,space0);
SamplerState CubeSampler :register(s2,space0);

float4 FragmentMain(float4 SvPosition : SV_POSITION) :  SV_TARGET
{

    float2 UV = SvPosition.xy ;
    float2 ScaledUVs = UV ;

    float3 CubeCorrdinates = GetCubemapVector(ScaledUVs,CubeFace);
    float3 N = normalize(CubeCorrdinates);

    float3x3 TangentToWorld = GetTangentBasis(N);

    float Roughness = float(MipIndex) / (NumMips - 1);
    float R4 = (Roughness * Roughness) *(Roughness * Roughness);

    uint CubeSize =  1 << (NumMips - 1);
    const float SoldAngleTexel = 4.0f * PI / float(6 * CubeSize * CubeSize)* 2.0f;

    float4 FilteredColor = 0;
    uint NumSamples = 64;
    for(uint i = 0 ; i < NumSamples ; i ++)
    {
        float2 E = Hammersley(i,NumSamples,0);

        E.y *= 0.995;
        float3 H = ImportanceSampleGGX(E,R4).xyz;
        float3 L = 2 * H.z *H - float3(0,0,1);

        float NoL = L.z;
        float NoH = H.z;

        if( NoL > 0)
        {
            float PDF = D_GGX(R4,NoH) * 0.25;
            float SolidAngleSample = 1.0 / (NumSamples * PDF);
            float Mip = 0.5f * log2(SolidAngleSample/ SoldAngleTexel);

            L = mul(L , TangentToWorld);
            FilteredColor +=  CubemapTexture.SampleLevel(CubeSampler,L,Mip);
        }


    }
    float4 OutColor = FilteredColor / NumSamples;

    return OutColor;
}
