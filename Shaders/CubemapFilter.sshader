
#include "MonteCarlo.hlsl"

cbuffer Global : register(b0)
{
    float2 SvPositionToUVScale;
    int CubeFace;
    int MipIndex;
    int NumMips;
}

struct VSInput
{
    [[vk::location(0)]] float3 Position : POSITION;
    [[vk::location(1)]] float2 UV : TEXCOORD0;
};

struct VSOutput
{
    float4 Pos : SV_POSITION;
    [[vk::location(1)]] float2 UV : TEXCOORD0;

};

float3 GetCubemapVector(float2 ScaledUVs, int InCubeFace)
{
	float3 CubeCoordinates;

	//@todo - this could be a 3x3 matrix multiply
	if (InCubeFace == 0)
	{
		CubeCoordinates = float3(1, -ScaledUVs.y, -ScaledUVs.x);
	}
	else if (InCubeFace == 1)
	{
		CubeCoordinates = float3(-1, -ScaledUVs.y, ScaledUVs.x);
	}
	else if (InCubeFace == 2)
	{
		CubeCoordinates = float3(ScaledUVs.x, 1, ScaledUVs.y);
	}
	else if (InCubeFace == 3)
	{
		CubeCoordinates = float3(ScaledUVs.x, -1, -ScaledUVs.y);
	}
	else if (InCubeFace == 4)
	{
		CubeCoordinates = float3(ScaledUVs.x, -ScaledUVs.y, 1);
	}
	else
	{
		CubeCoordinates = float3(-ScaledUVs.x, -ScaledUVs.y, -1);
	}

	return CubeCoordinates;
}


VSOutput VertexMain(VSInput input)
{
    VSOutput output = (VSOutput) 0;
    output.Pos = float4(input.Position,1.0f);
    output.UV = input.UV;
    return output;
}

float D_GGX(float a2 , float NoH)
{
    float d = ( NoH * a2 - NoH) * NoH + 1;
    return a2 / (PI *d *d );
}

TextureCube CubemapTexture : register(t1,space0);
SamplerState CubeSampler :register(s2,space0);


float4 PrefilerEnvMap_UE(float3 N ,float Roughness)
{
    float3x3 TangentToWorld = GetTangentBasis(N);

    float R4 = (Roughness * Roughness) *(Roughness * Roughness);

    uint CubeSize =  1 << (NumMips - 1);
    const float SoldAngleTexel = 4.0f * PI / float(6 * CubeSize * CubeSize)* 2.0f;

    float4 FilteredColor = 0;
    uint NumSamples = 64;
    for(uint i = 0 ; i < NumSamples ; i ++)
    {
        float2 E = Hammersley(i,NumSamples,0);

        E.y *= 0.995;
        float3 H = ImportanceSampleGGX(E,R4).xyz;
        float3 L = 2 * H.z *H - float3(0,0,1);

        float NoL = L.z;
        float NoH = H.z;

        if( NoL > 0)
        {
            float PDF = D_GGX(R4,NoH) * 0.25;
            float SolidAngleSample = 1.0 / (NumSamples * PDF);
            float Mip = 0.5f * log2(SolidAngleSample/ SoldAngleTexel);

            L = mul(L , TangentToWorld);
            FilteredColor +=  CubemapTexture.SampleLevel(CubeSampler,L,Mip);
        }


    }
    float4 OutColor = FilteredColor / NumSamples;

    return OutColor;
}


float3 PrefilterEnvMap_VulkanExample(float3 R, float roughness)
{
	float3 N = R;
	float3 V = R;
	float3 color = float3(0.0, 0.0, 0.0);
	float totalWeight = 0.0;

    float3x3 TangentToWorld = GetTangentBasis(N);

    float R4 = (roughness * roughness) *(roughness * roughness);
    uint CubeSize =  1 << (NumMips - 1);
    uint NumSamples = 32;
	for(uint i = 0u; i < NumSamples; i++) {
		float2 Xi = Hammersley(i, NumSamples,0);
		float3 H = ImportanceSampleGGX(Xi, R4);
		H = mul(H ,TangentToWorld);
		float3 L = 2.0 * dot(V, H) * H - V;
		float dotNL = clamp(dot(N, L), 0.0, 1.0);
		if(dotNL > 0.0) {
			// Filtering based on https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/

			float dotNH = clamp(dot(N, H), 0.0, 1.0);
			float dotVH = clamp(dot(V, H), 0.0, 1.0);

			// Probability Distribution Function
			float pdf = D_GGX(R4,dotNH) * dotNH / (4.0 * dotVH) + 0.0001;
			// Slid angle of current smple
			float omegaS = 1.0 / (float(NumSamples) * pdf);
			// Solid angle of 1 pixel across all cube faces
			float omegaP = 4.0 * PI / (6.0 * CubeSize * CubeSize);
			// Biased (+1.0) mip level for better result
			float mipLevel = roughness == 0.0 ? 0.0 : max(0.5 * log2(omegaS / omegaP) + 1.0, 0.0f);
			color += CubemapTexture.SampleLevel(CubeSampler, L, mipLevel).rgb * dotNL;
			totalWeight += dotNL;

		}
	}
	return (color / totalWeight);
}


float4 DownSampleCube(float3 N )
{
     return  CubemapTexture.SampleLevel(CubeSampler,N,0);
}

float4 FragmentMain(VSOutput input ) :  SV_TARGET
{

    float2 UV = input.UV ;
    float2 ScaledUVs = 2*UV -1.0f ;

    float3 CubeCorrdinates = GetCubemapVector(ScaledUVs,CubeFace);
    float3 N = normalize(CubeCorrdinates);

    float Roughness = float(MipIndex) / (NumMips - 1);
    float4 OutColor = float4(PrefilterEnvMap_VulkanExample(N,Roughness),1.0f);

    return OutColor;
}
