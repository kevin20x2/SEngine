#include "SCommon.hlsl"


struct VSInput
{
    [[vk::location(0)]] float3 Pos : POSITION ;
    [[vk::location(2)]] float4 Normal : NORMAL0;
    [[vk::location(3)]] float2 Uv : TEXCOORD0;
};


struct VSOutput
{
    float4 Pos : SV_POSITION;
    [[vk::location(1)]] float4 Normal : NORMAL0;
    [[vk::location(2)]] float2 Uv : TEXCOORD0;
    [[vk::location(3)]] float4 WorldPos : TEXCOORD2;
};



VSOutput VertexMain(VSInput input)
{
    VSOutput output = (VSOutput)0;
    float4 WorldPos = mul(float4(input.Pos.xyz,1.0f) , PrimitiveData.Model);
    output.Pos = mul(WorldPos,ViewData.ViewProjection);
    output.Normal = mul(float4( input.Normal.xyz,0.0f ) ,PrimitiveData.Model);
    output.WorldPos = WorldPos;
    output.Uv = input.Uv;
    return output;
}
Texture2D texColor : register(t3 ,space0);
SamplerState samplerColor : register(s4,space0);
TextureCube texCube : register(t5,space0);
SamplerState samplerCube : register(s6,space0);

TextureCube IrradianceCube : register(t7,space0);

Texture2D BRDFLUT :  register(t8,space0);

cbuffer MaterialBuffer :register(b9)
{
    float Roughness;
    float Metallic;
    float3 Color;
}

struct PSOutput
{
    float4 Color : SV_TARGET0 ;
    float4 Mask : SV_TARGET1 ;
};

float3 PrefilterReflection(float3 R ,float roughness)
{
    const float MAX_REFLECTION_LOD = 9.0;
    float lod = roughness * MAX_REFLECTION_LOD;

    float lodf = floor(lod);
    float lodc = ceil(lod);

    return texCube.SampleLevel(samplerCube , R,lod).rgb;
}


float3 F_SchlickR(float cosTheta, float3 F0, float roughness)
{
	return F0 + (max((1.0 - roughness).xxx, F0) - F0) * pow(1.0 - cosTheta, 5.0);
}

// Normal Distribution function --------------------------------------
float D_GGX(float dotNH, float roughness)
{
	float alpha = roughness * roughness;
	float alpha2 = alpha * alpha;
	float denom = dotNH * dotNH * (alpha2 - 1.0) + 1.0;
	return (alpha2)/(PI * denom*denom);
}

// Geometric Shadowing function --------------------------------------
float G_SchlicksmithGGX(float dotNL, float dotNV, float roughness)
{
	float r = (roughness + 1.0);
	float k = (r*r) / 8.0;
	float GL = dotNL / (dotNL * (1.0 - k) + k);
	float GV = dotNV / (dotNV * (1.0 - k) + k);
	return GL * GV;
}

// Fresnel function ----------------------------------------------------
float3 F_Schlick(float cosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float3 Uncharted2Tonemap(float3 x)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

float3 specularContribution(float3 L, float3 V, float3 N, float3 F0,float3 ALBEDO, float metallic, float roughness)
{
	// Precalculate vectors and dot products
	float3 H = normalize (V + L);
	float dotNH = clamp(dot(N, H), 0.0, 1.0);
	float dotNV = clamp(dot(N, V), 0.0, 1.0);
	float dotNL = clamp(dot(N, L), 0.0, 1.0);

	// Light color fixed
	float3 lightColor = float3(1.0, 1.0, 1.0);

	float3 color = float3(0.0, 0.0, 0.0);

	if (dotNL > 0.0) {
		// D = Normal distribution (Distribution of the microfacets)
		float D = D_GGX(dotNH, roughness);
		// G = Geometric shadowing term (Microfacets shadowing)
		float G = G_SchlicksmithGGX(dotNL, dotNV, roughness);
		// F = Fresnel factor (Reflectance depending on angle of incidence)
		float3 F = F_Schlick(dotNV, F0);
		float3 spec = D * F * G / (4.0 * dotNL * dotNV + 0.001);
		float3 kD = (float3(1.0, 1.0, 1.0) - F) * (1.0 - metallic);
		color += (kD * ALBEDO / PI + spec) * dotNL;
	}

	return color;
}

PSOutput FragmentMain(VSOutput input)
{
    PSOutput output = (PSOutput)0;
    float4 ALBEDO = texColor.Sample(samplerColor,input.Uv) *float4(Color, 1.0f) ;
    float3 V= normalize( ViewData.ViewPos - input.WorldPos.xyz);
    float3 N = normalize(input.Normal);
    float3 R = reflect(-V,N);

    float NToL = max(0.0f , dot(N , LightData.DirectionalLightDir));
    float NToV = max(0.0f , dot(N, V));

    float metallic = Metallic;
    float roughness = Roughness;

    float3 F0 = float3(0.04,0.04,0.04);
    F0 = lerp(F0,ALBEDO,metallic);

    float3 L = normalize(LightData.DirectionalLightDir);

    float3 Lo = specularContribution(L,V,N,F0,ALBEDO,metallic,roughness);

    float4 irradiance = IrradianceCube.Sample(samplerCube , N);
    float3 reflection = PrefilterReflection(R, roughness).rgb;
    float2 brdf = BRDFLUT.Sample(samplerColor,float2(NToV,roughness)).rg;

    float3 F = F_SchlickR(NToV ,F0,roughness);

    float3 Diffuse = irradiance * ALBEDO;
    float3 Specular = reflection * (F * brdf.x + brdf.y);

    float3 kD = 1.0 - F;
    kD *= 1.0 -metallic;
    float3 ambient = (kD * Diffuse + Specular);

    float3 FinalColor =  ambient + Lo ;
    FinalColor = Uncharted2Tonemap(FinalColor );
    FinalColor = FinalColor * (1.0f  / Uncharted2Tonemap((11.2f).xxx));

    FinalColor = pow(FinalColor, 1/2.2f);

    output.Color = float4(FinalColor.xyz, 1.0f) ;
    output.Mask = float4(1,0,0,1);
    return output;
}
