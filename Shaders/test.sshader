#include "SCommon.hlsl"


struct VSInput
{
    [[vk::location(0)]] float3 Pos : POSITION ;
    [[vk::location(2)]] float4 Normal : NORMAL0;
    [[vk::location(3)]] float2 Uv : TEXCOORD0;
};


struct VSOutput
{
    float4 Pos : SV_POSITION;
    [[vk::location(1)]] float4 Normal : NORMAL0;
    [[vk::location(2)]] float2 Uv : TEXCOORD0;
    [[vk::location(3)]] float4 WorldPos : TEXCOORD2;
};

VSOutput VertexMain(VSInput input)
{
    VSOutput output = (VSOutput)0;
    float4 WorldPos = mul(float4(input.Pos.xyz,1.0f) , PrimitiveData.Model);
    output.Pos = mul(WorldPos,ViewData.ViewProjection);
    output.Normal = mul(float4( input.Normal.xyz,0.0f ) ,PrimitiveData.Model);
    output.WorldPos = WorldPos;
    output.Uv = input.Uv;
    return output;
}
Texture2D texColor : register(t3 ,space0);
SamplerState samplerColor : register(s4,space0);
TextureCube texCube : register(t5,space0);
SamplerState samplerCube : register(s6,space0);

struct PSOutput
{
    float4 Color : SV_TARGET0 ;
    float4 Mask : SV_TARGET1 ;
};


PSOutput FragmentMain(VSOutput input)
{
    PSOutput output = (PSOutput)0;
    float4 ao = texColor.Sample(samplerColor,float2(input.Uv.x,1.0f - input.Uv.y));
    float3 ViewDir = normalize( ViewData.ViewPos - input.WorldPos.xyz);
    float3 WorldNormal = normalize(input.Normal);
    float NToL = max(0.0f , dot(WorldNormal , LightData.DirectionalLightDir));
    float3 LambertDiffuse = pow(NToL * 0.5f + 0.5f,2.0f) * ao;

    float3 reflectDir = reflect(-ViewDir,WorldNormal);
    float4 CubeColor = texCube.SampleLevel(samplerCube , reflectDir,8);

    float3 FinalColor =  CubeColor.rgb ;

    output.Color = float4(FinalColor, 1.0f) ;
    output.Mask = float4(1,0,0,1);
    return output;
}
